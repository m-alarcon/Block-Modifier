g Text,  Next: Moving Point,  Up: Basic

Inserting Text
==============

   To insert printing characters into the text you are editing, just
type them.  This inserts the characters you type into the buffer at the
cursor (that is, at "point"; *note Point::).  The cursor moves forward,
and any text after the cursor moves forward too.  If the text in the
buffer is `FOOBAR', with the cursor before the `B', then if you type
`XX', you get `FOOXXBAR', with the cursor still before the `B'.

   To "delete" text you have just inserted, use the large key labeled
<DEL>, <BACKSPACE> or <DELETE> which is a short distance above the
<RET> or <ENTER> key.  This is the key you normally use, outside Emacs,
for erasing the last character that you typed.  Regardless of the label
on that key, Emacs thinks of it as <DEL>, and that's what we call it in
this manual.

   The <DEL> key deletes the character _before_ the cursor.  As a
consequence, the cursor and all the characters after it move backwards.
If you type a printing character and then type <DEL>, they cancel out.

   On most computers, Emacs recognizes automatically which key ought to
be <DEL>, and sets it up that way.  But in some cases, especially with
text-only terminals, you will need to tell Emacs which key to use for
that purpose.  If the large key not far above the <RET> or <ENTER> key
doesn't delete backwards, you need to do this.  *Note DEL Does Not
Delete::, for an explanation of how.

   Most PC keyboards have both a <BACKSPACE> key a short ways above
<RET> or <ENTER>, and a <DELETE> key elsewhere.  On these keyboards,
Emacs supports when possible the usual convention that the <BACKSPACE>
key deletes backwards (it is <DEL>), while the <DELETE> key deletes
"forwards," deleting the character after point, the one underneath the
cursor, like `C-d' (see below).

   To end a line and start typing a new one, type <RET>.  This inserts
a newline character in the buffer.  If point is in the middle of a
line, <RET> splits the line.  Typing <DEL> when the cursor is at the
beginning of a line deletes the preceding newline, thus joining the
line with the preceding line.

   Emacs can split lines automatically when they become too long, if you
turn on a special minor mode called "Auto Fill" mode.  *Note Filling::,
for how to use Auto Fill mode.

   If you prefer to have text characters replace (overwrite) existing
text rather than shove it to the right, you can enable Overwrite mode,
a minor mode.  *Note Minor Modes::.

   Direct insertion works for printing characters and <SPC>, but other
characters act as editing commands and do not insert themselves.  If you
need to insert a control character or a character whose code is above
200 octal, you must "quote" it by typing the character `Control-q'
(`quoted-insert') first.  (This character's name is normally written
`C-q' for short.)  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, it serves only to terminate the
     sequence.  Any other non-digit terminates the sequence and then
     acts as normal input--thus, `C-q 1 0 1 B' inserts `AB'.

     The use of octal sequences is disabled in ordinary non-binary
     Overwrite mode, to give you a convenient way to insert a digit
     instead of overwriting with it.

When multibyte characters are enabled, if you specify a code in the
range 0200 through 0377 octal, `C-q' assumes that you intend to use
some ISO 8859-N character set, and converts the specified code to the
corresponding Emacs character code.  *Note Enabling Multibyte::.  You
select _which_ of the ISO 8859 character sets to use through your
choice of language environment (*note Language Environments::).

   To use decimal or hexadecimal instead of octal, set the variable
`read-quoted-char-radix' to 10 or 16.  If the radix is greater than 10,
some letters starting with `a' serve as part of a character code, just
like digits.

   A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::).

   Customization information: <DEL> in most modes runs the command
`delete-backward-char'; <RET> runs the command `newline', and
self-inserting printing characters run the command `self-insert', which
inserts whatever character was typed to invoke it.  Some major modes
rebind <DEL> to other commands.


File: emacs,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

Changing the Location of Point
==============================

   To do more than insert characters, you have to know how to move point
(*note Point::).  The simplest way to do this is with arrow keys, or by
clicking the left mouse button where you want to move to.

   There are also control and meta characters for cursor motion.  Some
are equivalent to the arrow keys (these date back to the days before
terminals had arrow keys, and are usable on terminals which don't have
them).  Others do more sophisticated things.

`C-a'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
     Move to the end of the line (`end-of-line').

`C-f'
     Move forward one character (`forward-char').  The right-arrow key
     does the same thing.

`C-b'
     Move backward one character (`backward-char').  The left-arrow key
     has the same effect.

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`C-n'
     Move down one line, vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you end in the middle of the
     next.  The down-arrow key does the same thing.

`C-p'
     Move up one line, vertically (`previous-line').  The up-arrow key
     has the same effect.

`M-r'
     Move point to left margin, vertically centered in the window
     (`move-to-window-line').  Text does not move on the screen.

     A numeric argument says which screen line to place point on.  It
     counts screen lines down from the top of the window (zero for the
     top line).  A negative argument counts lines from the bottom (-1
     for the bottom line).

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`C-v'
     Scroll the display one screen forward, and move point if necessary
     to put it on the screen (`scroll-up').  This doesn't always move
     point, but it is commonly used to do so.  If your keyboard has a
     <PAGEDOWN> key, it does the same thing.

     Scrolling commands are further described in *Note Scrolling::.

`M-v'
     Scroll one screen backward, and move point if necessary to put it
     on the screen (`scroll-down').  This doesn't always move point, but
     it is commonly used to do so.  The <PAGEUP> key has the same
     effect.

`M-x goto-char'
     Read a number N and move point to buffer position N.  Position 1
     is the beginning of the buffer.

`M-x goto-line'
     Read a number N and move point to line number N.  Line 1 is the
     beginning of the buffer.

`C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for `C-n' and `C-p' (`set-goal-column').  Henceforth, those
     commands always move to this column in each line moved into, or as
     close as possible given the contents of the line.  This goal
     column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' once again
     try to stick to a fixed horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then `C-n'
and `C-p', when starting at the end of the line, move to the end of
another line.  Normally, `track-eol' is `nil'.  *Note Variables::, for
how to set variables such as `track-eol'.

   `C-n' normally gets an error when you use it on the last line of the
buffer (just as `C-p' gets an error on the first line).  But if you set
the variable `next-line-add-newlines' to a non-`nil' value, `C-n' on
the last line of a buffer creates an additional line at the end and
moves down onto it.


File: emacs,  Node: Erasing,  Next: Undo,  Prev: Moving Point,  Up: Basic

Erasing Text
============

`<DEL>'
     Delete the character before point (`delete-backward-char').

`C-d'
     Delete the character after point (`delete-char').

`<DELETE>'
`<BACKSPACE>'
     One of these keys, whichever is the large key above the <RET> or
     <ENTER> key, deletes the character before point, like <DEL>.  If
     that is <BACKSPACE>, and your keyboard also has <DELETE>, then
     <DELETE> deletes forwards, like `C-d'.

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the <DEL> key which deletes the character
before point (that is, before the cursor).  Another key, `Control-d'
(`C-d' for short), deletes the character after point (that is, the
character that the cursor is on).  This shifts the rest of the text on
the line to the left.  If you type `C-d' at the end of a line, it joins
together that line and the next line.

   To erase a larger amount of text, use the `C-k' key, which kills a
line at a time.  If you type `C-k' at the beginning or middle of a
line, it kills all the text up to the end of the line.  If you type
`C-k' at the end of a line, it joins that line and the next line.

   *Note Killing::, for more flexible ways of killing text.


File: emacs,  Node: Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

Undoing Changes
===============

   You can undo all the recent changes in the buffer text, up to a
certain point.  Each buffer records changes individually, and the undo
command always applies to the current buffer.  Usually each editing
command makes a separate entry in the undo records, but some commands
such as `query-replace' make many entries, and very simple commands
such as self-inserting characters are often grouped to make undoing less
tedious.

`C-x u'
     Undo one batch of changes--usually, one command worth (`undo').

`C-_'
     The same.

`C-u C-x u'
     Undo one batch of changes in the region.

   The command `C-x u' or `C-_' is how you undo.  The first time you
give this command, it undoes the last change.  Point moves back to
where it was before the command that made the change.

   Consecutive repetitions of `C-_' or `C-x u' undo earlier and earlier
changes, back to the limit of the undo information available.  If all
recorded changes have already been undone, the undo command displays an
error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the previous undo commands become
ordinary changes that you can undo.  Thus, to redo changes you have
undone, type `C-f' or any other command that will harmlessly break the
sequence of undoing, then type more undo commands.

   Ordinary undo applies to all changes made in the current buffer.  You
can also perform "selective undo", limited to the current region.  To
do this, specify the region you want, then run the `undo' command with
a prefix argument (the value does not matter): `C-u C-x u' or `C-u
C-_'.  This undoes the most recent change in the region.  To undo
further changes in the same region, repeat the `undo' command (no
prefix argument is needed).  In Transient Mark mode, any use of `undo'
when there is an active region performs selective undo; you do not need
a prefix argument.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  At this time, all the
modifications you made have been canceled.  Whenever an undo command
makes the stars disappear from the mode line, it means that the buffer
contents are the same as they were when the file was last read in or
saved.

   If you do not remember whether you changed the buffer deliberately,
type `C-_' once.  When you see the last change you made undone, you
will see whether it was an intentional change.  If it was an accident,
leave it undone.  If it was deliberate, redo the change as described
above.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit.

   You cannot undo mere cursor motion; only changes in the buffer
contents save undo information.  However, some cursor motion commands
set the mark, so if you use these commands from time to time, you can
move back to the neighborhoods you have moved through by popping the
mark ring (*note Mark Ring::).

   When the undo information for a buffer becomes too large, Emacs
discards the oldest undo information from time to time (during garbage
collection).  You can specify how much undo information to keep by
setting two variables: `undo-limit' and `undo-strong-limit'.  Their
values are expressed in units of bytes of space.

   The variable `undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 20000.  The variable `undo-strong-limit' sets a stricter limit: the
command which pushes the size past this amount is itself forgotten.
Its default value is 30000.

   Regardless of the values of those variables, the most recent change
is never discarded, so there is no danger that garbage collection
occurring right after an unintentional large change might prevent you
from undoing it.

   The reason the `undo' command has two keys, `C-x u' and `C-_', set
up to run it is that it is worthy of a single-character key, but on
some keyboards it is not obvious how to type `C-_'.  `C-x u' is an
alternative you can type straightforwardly on any terminal.


File: emacs,  Node: Basic Files,  Next: Basic Help,  Prev: Undo,  Up: Basic

Files
=====

   The commands described above are sufficient for creating and altering
text in an Emacs buffer; the more advanced Emacs commands just make
things easier.  But to keep any text permanently you must put it in a
"file".  Files are named units of text which are stored by the
operating system for you to retrieve later by name.  To look at or use
the contents of a file in any way, including editing the file with
Emacs, you must specify the file name.

   Consider a file named `/usr/rms/foo.c'.  In Emacs, to begin editing
this file, type

     C-x C-f /usr/rms/foo.c <RET>

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type <RET> to terminate the argument (*note
Minibuffer::).

   Emacs obeys the command by "visiting" the file: creating a buffer,
copying the contents of the file into the buffer, and then displaying
the buffer for you to edit.  If you alter the text, you can "save" the
new text in the file by typing `C-x C-s' (`save-buffer').  This makes
the changes permanent by copying the altered buffer contents back into
the file `/usr/rms/foo.c'.  Until you save, the changes exist only
inside Emacs, and the file `foo.c' is unaltered.

   To create a file, just visit the file with `C-x C-f' as if it
already existed.  This creates an empty buffer in which you can insert
the text you want to put in the file.  The file is actually created when
you save this buffer with `C-x C-s'.

   Of course, there is a lot more to learn about using files.  *Note
Files::.


File: emacs,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

Help
====

   If you forget what a key does, you can find out with the Help
character, which is `C-h' (or <F1>, which is an alias for `C-h').  Type
`C-h k' followed by the key you want to know about; for example, `C-h k
C-n' tells you all about what `C-n' does.  `C-h' is a prefix key; `C-h
k' is just one of its subcommands (the command `describe-key').  The
other subcommands of `C-h' provide different kinds of help.  Type `C-h'
twice to get a description of all the help facilities.  *Note Help::.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

Blank Lines
===========

   Here are special commands and techniques for putting in and taking
out blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   When you want to insert a new line of text before an existing line,
you can do it by typing the new line of text, followed by <RET>.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to do
using the key `C-o' (`open-line'), which inserts a newline after point
but leaves point in front of the newline.  After `C-o', type the text
for the new line.  `C-o F O O' has the same effect as `F O O <RET>',
except for the final location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument to tell it how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, then `C-o'
command inserts the fill prefix on the new line, when you use it at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  `C-x C-o' in a run of several blank
lines deletes all but one of them.  `C-x C-o' on a solitary blank line
deletes that blank line.  When point is on a nonblank line, `C-x C-o'
deletes any blank lines following that nonblank line.


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

Continuation Lines
==================

   If you add too many characters to one line without breaking it with
<RET>, the line grows to occupy two (or more) lines on the screen.  On
graphical displays, Emacs indicates line wrapping with small bent
arrows in the fringes to the left and right of the window.  On
text-only terminals, Emacs displays a `\' character at the right margin
of a screen line if it is not the last in its text line.  This `\'
character says that the following screen line is not really a distinct
line in the text, just a "continuation" of a line too long to fit the
screen.  Continuation is also called "line wrapping".

   When line wrapping occurs before a character that is wider than one
column, some columns at the end of the previous screen line may b